import { AISuggestion, AIAnalysisResult } from './types';
import { medicalScales } from './scales-data';

/**
 * ü§ñ ENHANCED AI ANALYZER - Sistema Auto-Actualizable
 * 
 * Este sistema se actualiza autom√°ticamente cuando se agregan nuevas escalas m√©dicas.
 * Los patrones se generan din√°micamente desde scales-data.ts
 * 
 * INSTRUCCIONES PARA CLAUDE CODE:
 * ================================
 * 
 * Cuando agregues una nueva escala m√©dica:
 * 1. ‚úÖ Agregar escala en scales-data.ts (se auto-actualiza)
 * 2. üîß Si la predicci√≥n no funciona bien, actualizar MEDICAL_SYNONYMS abajo
 * 3. üìù Probar con texto de ejemplo para validar
 * 
 * Ejemplo de actualizaci√≥n:
 * Si agregas escala "MOCA" y no se detecta:
 * - Agregar: 'moca': ['montreal', 'evaluacion cognitiva', 'screening cognitivo']
 * 
 * NO TOCAR: Las funciones principales se actualizan solas
 */

// ============================================================================
// CONFIGURACI√ìN DE SIN√ìNIMOS M√âDICOS
// ============================================================================
// üîß √ÅREA EDITABLE: Agregar sin√≥nimos aqu√≠ si las predicciones fallan
const MEDICAL_SYNONYMS: { [key: string]: string[] } = {
  // Neurol√≥gicos
  'ictus': ['stroke', 'avc', 'accidente cerebrovascular', 'derrame cerebral', 'embolia cerebral'],
  'temblor': ['temblores', 'shake', 'vibraci√≥n', 'oscilaci√≥n'],
  'parkinson': ['enfermedad de parkinson', 'parkinsonismo', 'ep'],
  'hemiparesia': ['hemiplejia', 'debilidad unilateral', 'par√°lisis parcial'],
  'disartria': ['habla arrastrada', 'dificultad hablar', 'lenguaje afectado'],
  'disfagia': ['dificultad tragar', 'problemas degluci√≥n'],
  'glasgow': ['escala glasgow', 'gcs', 'nivel conciencia'],
  'conciencia': ['consciencia', 'alerta', 'vigilia', 'awareness'],
  
  // Psiqui√°tricos - CR√çTICOS para detecci√≥n
  'depresion': ['depresi√≥n', 'deprimido', 'depresivo', 'tristeza', 'melancol√≠a', 'triste', 'bajo animo', 'estado animo'],
  'deprimido': ['depresi√≥n', 'depresivo', 'tristeza', 'melancol√≠a', 'triste', 'bajo animo'],
  'depresivo': ['depresi√≥n', 'deprimido', 'tristeza', 'melancol√≠a', 'triste'],
  'tristeza': ['depresi√≥n', 'deprimido', 'depresivo', 'melancol√≠a', 'triste'],
  'major_depressive_disorder': ['depresi√≥n mayor', 'trastorno depresivo', 'episodio depresivo', 'deprimido', 'tristeza'],
  'beck': ['beck depression inventory', 'inventario beck', 'bdi', 'depresi√≥n beck'],
  'ansiedad': ['ansioso', 'nervioso', 'preocupaci√≥n', 'angustia'],
  'suicida': ['suicidio', 'autolisis', 'pensamientos muerte', 'ideaci√≥n suicida'],
  'anhedonia': ['falta placer', 'desinter√©s', 'apat√≠a', 'p√©rdida inter√©s'],
  'insomnio': ['problemas sue√±o', 'dificultad dormir', 'desvelo'],
  'demencia': ['deterioro cognitivo', 'alzheimer', 'p√©rdida memoria'],
  'agitacion': ['agitaci√≥n', 'inquietud', 'hiperactividad', 'nerviosismo'],
  
  // Cardiovasculares
  'fibrilacion': ['fibrilaci√≥n auricular', 'fa', 'arritmia', 'latido irregular'],
  'hemorragia': ['sangrado', 'hemorrhage', 'p√©rdida sangre'],
  'anticoagulacion': ['anticoagulante', 'warfarina', 'acenocumarol', 'sintrom'],
  
  // Cognitivos
  'memoria': ['recuerdo', 'recordar', 'amnesia', 'olvido'],
  'orientacion': ['orientaci√≥n', 'desorientado', 'confuso', 'ubicaci√≥n'],
  'concentracion': ['concentraci√≥n', 'atenci√≥n', 'foco', 'distracci√≥n'],
  
  // Escalas espec√≠ficas
  'nihss': ['national institutes health stroke scale', 'escala stroke'],
  'updrs': ['unified parkinson disease rating scale', 'escala parkinson'],
  'mmse': ['mini mental', 'minimental', 'examen mental'],
  'moca': ['montreal cognitive assessment', 'evaluacion cognitiva montreal'],
  'rankin': ['modified rankin scale', 'mrs', 'escala rankin'],
  'ashworth': ['escala ashworth', 'tono muscular', 'espasticidad'],
  'midas': ['migraine disability assessment', 'discapacidad migra√±a'],
  'hit6': ['headache impact test', 'impacto cefalea']
};

// Lista de palabras negativas para detecci√≥n de negaciones
const NEGATION_WORDS = [
  'sin', 'no', 'ausente', 'negativo', 'niega', 'descarta', 'ausencia',
  'libre', 'carece', 'falta', 'inexistente', 'nulo'
];

// Palabras que indican severidad/urgencia
const SEVERITY_INDICATORS = {
  high: ['severo', 'grave', 'intenso', 'agudo', 'cr√≠tico', 'urgente', 'emergencia'],
  moderate: ['moderado', 'intermedio', 'regular'],
  mild: ['leve', 'ligero', 'm√≠nimo', 'poco', 'escaso']
};

// ============================================================================
// SISTEMA AUTO-GENERADOR DE PATRONES
// ============================================================================

interface AutoGeneratedPattern {
  scaleId: string;
  scaleName: string;
  category: string;
  keywords: string[];
  baseConfidence: number;
  reason: string;
}

/**
 * üîÑ AUTO-GENERA PATRONES desde scales-data.ts
 * Se ejecuta autom√°ticamente - NO MODIFICAR
 */
const generatePatternsFromScales = (): AutoGeneratedPattern[] => {
  const patterns: AutoGeneratedPattern[] = [];
  
  medicalScales.forEach(scale => {
    const keywords: string[] = [];
    
    // 1. Extraer del nombre de la escala
    const nameKeywords = extractKeywordsFromText(scale.name.toLowerCase());
    keywords.push(...nameKeywords);
    
    // 2. Extraer de la descripci√≥n
    const descriptionKeywords = extractKeywordsFromText(scale.description.toLowerCase());
    keywords.push(...descriptionKeywords);
    
    // 3. Extraer de las etiquetas de los √≠tems
    scale.items.forEach(item => {
      const itemKeywords = extractKeywordsFromText(item.label.toLowerCase());
      keywords.push(...itemKeywords);
      
      // Tambi√©n de las opciones m√°s importantes
      item.options.slice(0, 3).forEach(option => {
        const optionKeywords = extractKeywordsFromText(option.toLowerCase());
        keywords.push(...optionKeywords);
      });
    });
    
    // 4. Agregar sin√≥nimos si existen
    const scaleIdKeywords = MEDICAL_SYNONYMS[scale.id] || [];
    keywords.push(...scaleIdKeywords);
    
    // Buscar sin√≥nimos por palabras clave encontradas
    keywords.forEach(keyword => {
      const synonyms = MEDICAL_SYNONYMS[keyword] || [];
      keywords.push(...synonyms);
    });
    
    // 5. Limpiar y deduplicar keywords
    const cleanKeywords = [...new Set(keywords)]
      .filter(k => k && k.length > 2) // Palabras de al menos 3 caracteres
      .filter(k => !['0', '1', '2', '3', 'no', 'si', 'es', 'un', 'una', 'el', 'la'].includes(k));
    
    // 6. Determinar confianza base por categor√≠a
    let baseConfidence = 0.7; // Por defecto
    
    if (scale.category.toLowerCase().includes('neurol√≥gic')) baseConfidence = 0.8;
    if (scale.category.toLowerCase().includes('psiqui√°tric')) baseConfidence = 0.85;
    if (scale.category.toLowerCase().includes('cognitiv')) baseConfidence = 0.8;
    if (scale.category.toLowerCase().includes('cardiovascular')) baseConfidence = 0.75;
    
    // 7. Crear el patr√≥n
    patterns.push({
      scaleId: scale.id,
      scaleName: scale.name,
      category: scale.category,
      keywords: cleanKeywords,
      baseConfidence,
      reason: `Evaluaci√≥n de ${scale.category.toLowerCase()}`
    });
  });
  
  console.log(`üîÑ Auto-generated ${patterns.length} patterns from scales`);
  return patterns;
};

/**
 * Extrae palabras clave m√©dicamente relevantes de un texto
 */
const extractKeywordsFromText = (text: string): string[] => {
  // Limpiar texto
  const cleanText = text
    .toLowerCase()
    .replace(/[^\w√°√©√≠√≥√∫√±√º\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  
  const words = cleanText.split(' ');
  const keywords: string[] = [];
  
  // Extraer palabras individuales relevantes
  words.forEach(word => {
    if (word.length >= 3 && !['con', 'por', 'para', 'desde', 'hasta', 'entre'].includes(word)) {
      keywords.push(word);
    }
  });
  
  // Extraer frases de 2-3 palabras
  for (let i = 0; i < words.length - 1; i++) {
    const phrase2 = `${words[i]} ${words[i + 1]}`;
    if (phrase2.length >= 6) keywords.push(phrase2);
    
    if (i < words.length - 2) {
      const phrase3 = `${words[i]} ${words[i + 1]} ${words[i + 2]}`;
      if (phrase3.length >= 10) keywords.push(phrase3);
    }
  }
  
  return keywords;
};

// ============================================================================
// AN√ÅLISIS CONTEXTUAL MEJORADO
// ============================================================================

/**
 * Normaliza texto para an√°lisis (sin acentos, min√∫sculas)
 */
const normalizeText = (text: string): string => {
  return text
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^\w\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
};

/**
 * üîç AN√ÅLISIS DE NEGACIONES MEJORADO
 * Detecta si los s√≠ntomas est√°n siendo negados
 */
const analyzeNegations = (text: string, keyword: string): number => {
  const normalizedText = normalizeText(text);
  const words = normalizedText.split(' ');
  
  // Buscar posici√≥n del keyword
  let keywordPosition = -1;
  for (let i = 0; i < words.length; i++) {
    if (words.slice(i, i + keyword.split(' ').length).join(' ').includes(keyword)) {
      keywordPosition = i;
      break;
    }
  }
  
  if (keywordPosition === -1) return 1; // No encontrado, confianza normal
  
  // Buscar negaciones en las 5 palabras anteriores al keyword
  const contextStart = Math.max(0, keywordPosition - 5);
  const contextWords = words.slice(contextStart, keywordPosition + 1);
  
  for (const negWord of NEGATION_WORDS) {
    if (contextWords.includes(normalizeText(negWord))) {
      console.log(`‚ùå Negation detected: "${negWord}" near "${keyword}"`);
      return 0.1; // Reducir confianza significativamente
    }
  }
  
  return 1; // Sin negaci√≥n detectada
};

/**
 * üéØ AN√ÅLISIS DE PROXIMIDAD
 * Calcula si las palabras clave est√°n cerca unas de otras
 */
const calculateProximityScore = (text: string, keywords: string[]): number => {
  const normalizedText = normalizeText(text);
  const words = normalizedText.split(' ');
  const keywordPositions: number[] = [];
  
  // Encontrar posiciones de todos los keywords
  keywords.forEach(keyword => {
    const normalizedKeyword = normalizeText(keyword);
    for (let i = 0; i < words.length; i++) {
      if (words[i].includes(normalizedKeyword) || normalizedKeyword.includes(words[i])) {
        keywordPositions.push(i);
      }
    }
  });
  
  if (keywordPositions.length < 2) return 1;
  
  // Calcular distancia promedio entre keywords
  let totalDistance = 0;
  let pairs = 0;
  
  for (let i = 0; i < keywordPositions.length; i++) {
    for (let j = i + 1; j < keywordPositions.length; j++) {
      totalDistance += Math.abs(keywordPositions[i] - keywordPositions[j]);
      pairs++;
    }
  }
  
  const avgDistance = totalDistance / pairs;
  
  // Boost si las palabras est√°n cerca (distancia < 10 palabras)
  if (avgDistance < 10) return 1.3;
  if (avgDistance < 20) return 1.1;
  
  return 1;
};

/**
 * üìä AN√ÅLISIS DE SEVERIDAD
 * Detecta indicadores de severidad en el texto
 */
const analyzeSeverity = (text: string): { level: string; multiplier: number } => {
  const normalizedText = normalizeText(text);
  
  // Buscar indicadores de alta severidad
  for (const indicator of SEVERITY_INDICATORS.high) {
    if (normalizedText.includes(normalizeText(indicator))) {
      return { level: 'high', multiplier: 1.5 };
    }
  }
  
  // Buscar indicadores de severidad moderada
  for (const indicator of SEVERITY_INDICATORS.moderate) {
    if (normalizedText.includes(normalizeText(indicator))) {
      return { level: 'moderate', multiplier: 1.2 };
    }
  }
  
  // Buscar indicadores de severidad leve
  for (const indicator of SEVERITY_INDICATORS.mild) {
    if (normalizedText.includes(normalizeText(indicator))) {
      return { level: 'mild', multiplier: 0.9 };
    }
  }
  
  return { level: 'normal', multiplier: 1 };
};

/**
 * üßÆ C√ÅLCULO DE CONFIANZA MEJORADO
 * Combina m√∫ltiples factores para una predicci√≥n m√°s precisa
 */
const calculateEnhancedConfidence = (
  normalizedText: string, 
  pattern: AutoGeneratedPattern
): number => {
  const words = normalizedText.split(' ');
  const matchedKeywords: string[] = [];
  let totalNegationFactor = 1;
  
  console.log(`üîç Testing pattern ${pattern.scaleId} against text:`, normalizedText.substring(0, 100));
  console.log(`üìù Pattern keywords:`, pattern.keywords.slice(0, 10));
  
  // 1. Buscar coincidencias de keywords
  pattern.keywords.forEach(keyword => {
    const normalizedKeyword = normalizeText(keyword);
    
    if (normalizedText.includes(normalizedKeyword)) {
      matchedKeywords.push(keyword);
      
      // Aplicar an√°lisis de negaci√≥n
      const negationFactor = analyzeNegations(normalizedText, normalizedKeyword);
      totalNegationFactor *= negationFactor;
      
      console.log(`  ‚úÖ MATCH: "${keyword}" (negation: ${negationFactor})`);
    }
  });
  
  if (matchedKeywords.length === 0) return 0;
  
  // 2. Factores base
  const keywordRatio = matchedKeywords.length / pattern.keywords.length;
  const textLengthFactor = Math.min(words.length / 50, 1);
  const baseConfidence = pattern.baseConfidence;
  
  // 3. An√°lisis de proximidad
  const proximityScore = calculateProximityScore(normalizedText, matchedKeywords);
  
  // 4. An√°lisis de severidad
  const severity = analyzeSeverity(normalizedText);
  
  // 5. Combinaci√≥n de factores
  let confidence = baseConfidence * keywordRatio * (0.5 + 0.5 * textLengthFactor);
  
  // Aplicar multiplicadores
  confidence *= totalNegationFactor; // Negaciones
  confidence *= proximityScore; // Proximidad
  confidence *= severity.multiplier; // Severidad
  
  // Boosts por n√∫mero de matches
  if (matchedKeywords.length >= 3) confidence *= 1.4;
  else if (matchedKeywords.length >= 2) confidence *= 1.2;
  
  // Boost por categor√≠a especializada
  if (pattern.category.toLowerCase().includes('psiqui√°tric') || 
      pattern.category.toLowerCase().includes('cognitiv')) {
    confidence *= 1.3;
  }
  
  console.log(`  üìà Enhanced confidence: ${confidence.toFixed(3)} ` +
    `(matches: ${matchedKeywords.length}, proximity: ${proximityScore}, ` +
    `severity: ${severity.level}, negation: ${totalNegationFactor})`);
  
  return Math.min(confidence, 1);
};

// ============================================================================
// FUNCI√ìN PRINCIPAL DE AN√ÅLISIS
// ============================================================================

/**
 * üöÄ AN√ÅLISIS PRINCIPAL MEJORADO
 * Combina auto-generaci√≥n de patrones con an√°lisis contextual avanzado
 */
export const analyzeTextEnhanced = (text: string): AIAnalysisResult => {
  console.log('üöÄ Enhanced AI Analyzer - Analyzing text:', text.substring(0, 100) + '...');
  
  if (!text || text.trim().length < 5) { // Reducido de 10 a 5
    console.log('‚ùå Text too short, skipping analysis');
    return {
      suggestions: [],
      timestamp: Date.now()
    };
  }
  
  // DEBUGGING ESPECIAL PARA "DEPRIMIDO"
  if (text.toLowerCase().includes('deprimido')) {
    console.log('üîç DEBUGGING: Detectado "deprimido" en el texto');
  }
  
  // 1. Auto-generar patrones desde las escalas
  const autoPatterns = generatePatternsFromScales();
  
  // 2. Normalizar texto
  const normalizedText = normalizeText(text);
  const suggestions: AISuggestion[] = [];
  
  // DETECCI√ìN INTELIGENTE - Incluye variaciones de g√©nero y categor√≠as
  const smartDetections: { [key: string]: string[] } = {
    // Psiqui√°tricas - Variaciones de g√©nero y t√©rminos
    'deprimid': ['major_depressive_disorder', 'beck_depression_inventory'], // captura deprimido/deprimida
    'depresiv': ['major_depressive_disorder', 'beck_depression_inventory'], // captura depresivo/depresiva
    'depresion': ['major_depressive_disorder', 'beck_depression_inventory'],
    'tristeza': ['major_depressive_disorder', 'beck_depression_inventory'],
    'triste': ['major_depressive_disorder', 'beck_depression_inventory'],
    'melancolico': ['major_depressive_disorder', 'beck_depression_inventory'],
    'melancolica': ['major_depressive_disorder', 'beck_depression_inventory'],
    'suicid': ['major_depressive_disorder', 'beck_depression_inventory'], // suicida/suicidio
    'ansiedad': ['major_depressive_disorder', 'beck_depression_inventory'],
    'ansios': ['major_depressive_disorder', 'beck_depression_inventory'], // ansioso/ansiosa
    
    // Neurol√≥gicas - Parkinson
    'temblor': ['parkinson_diagnosis', 'updrs3', 'hoehn_yahr'],
    'parkinson': ['parkinson_diagnosis', 'updrs1', 'updrs3', 'hoehn_yahr'],
    'rigidez': ['parkinson_diagnosis', 'updrs3', 'ashworth'],
    'bradicinesia': ['parkinson_diagnosis', 'updrs3'],
    'bradiquinesia': ['parkinson_diagnosis', 'updrs3'],
    'festinacion': ['parkinson_diagnosis', 'updrs2'],
    
    // Neurol√≥gicas - Stroke
    'hemiparesia': ['nihss', 'mrs'],
    'hemiplejia': ['nihss', 'mrs'],
    'disartria': ['nihss'],
    'disfagia': ['nihss'],
    'stroke': ['nihss', 'mrs'],
    'ictus': ['nihss', 'mrs', 'aspects'],
    'avc': ['nihss', 'mrs'],
    
    // Cognitivas
    'memoria': ['mmse', 'moca'],
    'olvid': ['mmse', 'moca'], // olvido/olvidos
    'confus': ['mmse', 'moca', 'glasgow'], // confuso/confusa/confusi√≥n
    'desorient': ['mmse', 'moca'], // desorientado/desorientada/desorientaci√≥n
    'demencia': ['mmse', 'moca', 'neuropsychiatric_inventory'],
    'alzheimer': ['mmse', 'moca', 'neuropsychiatric_inventory'],
    'cognitiv': ['mmse', 'moca'], // cognitivo/cognitiva
    
    // Neuropsiqui√°tricas
    'agitacion': ['neuropsychiatric_inventory'],
    'agitad': ['neuropsychiatric_inventory'], // agitado/agitada
    'alucinacion': ['neuropsychiatric_inventory'],
    'alucinand': ['neuropsychiatric_inventory'], // alucinando
    'deliri': ['neuropsychiatric_inventory'], // delirio/delirante
    'comportamiento': ['neuropsychiatric_inventory'],
    
    // Cefalea
    'cefalea': ['midas', 'hit6'],
    'migrana': ['midas', 'hit6'],
    'dolor cabeza': ['midas', 'hit6'],
    'dolor de cabeza': ['midas', 'hit6'],
    
    // Glasgow/Conciencia
    'glasgow': ['glasgow'],
    'conciencia': ['glasgow', 'nihss'],
    'coma': ['glasgow', 'nihss'],
    'estupor': ['glasgow']
  };
  
  // DETECCI√ìN POR CATEGOR√çAS M√âDICAS
  const categoryDetections: { [key: string]: string[] } = {
    'psiquiatria': ['major_depressive_disorder', 'beck_depression_inventory', 'neuropsychiatric_inventory'],
    'psiquiatrica': ['major_depressive_disorder', 'beck_depression_inventory', 'neuropsychiatric_inventory'],
    'psiquiatrico': ['major_depressive_disorder', 'beck_depression_inventory', 'neuropsychiatric_inventory'],
    'neurologia': ['nihss', 'glasgow', 'updrs1', 'updrs3', 'parkinson_diagnosis', 'hoehn_yahr'],
    'neurologica': ['nihss', 'glasgow', 'updrs1', 'updrs3', 'parkinson_diagnosis', 'hoehn_yahr'],
    'neurologico': ['nihss', 'glasgow', 'updrs1', 'updrs3', 'parkinson_diagnosis', 'hoehn_yahr'],
    'cognitiva': ['mmse', 'moca'],
    'cognitivo': ['mmse', 'moca'],
    'cardiovascular': ['cha2ds2vasc', 'hasbled'],
    'cardiologia': ['cha2ds2vasc', 'hasbled']
  };

  // Buscar detecciones inteligentes (con variaciones de g√©nero)
  Object.keys(smartDetections).forEach(keyword => {
    if (normalizedText.includes(keyword)) {
      console.log(`üéØ SMART DETECTION: "${keyword}" found in text`);
      smartDetections[keyword].forEach(scaleId => {
        suggestions.push({
          scaleId,
          confidence: 0.9,
          keywords: [keyword],
          reason: `Detecci√≥n inteligente de "${keyword}"`
        });
      });
    }
  });

  // Buscar detecciones por categor√≠a m√©dica
  Object.keys(categoryDetections).forEach(category => {
    if (normalizedText.includes(category)) {
      console.log(`üè• CATEGORY DETECTION: "${category}" found in text`);
      categoryDetections[category].forEach(scaleId => {
        suggestions.push({
          scaleId,
          confidence: 0.8, // Ligeramente menor que detecci√≥n directa
          keywords: [category],
          reason: `Detecci√≥n por categor√≠a "${category}"`
        });
      });
    }
  });
  
  // 3. Analizar cada patr√≥n
  autoPatterns.forEach(pattern => {
    const confidence = calculateEnhancedConfidence(normalizedText, pattern);
    
    // Umbral ultra-sensible para detecci√≥n m√©dica
    if (confidence >= 0.05) {
      const matchedKeywords = pattern.keywords.filter(keyword => 
        normalizedText.includes(normalizeText(keyword))
      );
      
      suggestions.push({
        scaleId: pattern.scaleId,
        confidence,
        keywords: matchedKeywords,
        reason: pattern.reason
      });
    }
  });
  
  // 4. Deduplicar sugerencias (evitar escalas repetidas)
  const uniqueSuggestions = suggestions.reduce((acc, current) => {
    const exists = acc.find(item => item.scaleId === current.scaleId);
    if (!exists) {
      acc.push(current);
    } else if (current.confidence > exists.confidence) {
      // Reemplazar si la nueva tiene mayor confianza
      const index = acc.findIndex(item => item.scaleId === current.scaleId);
      acc[index] = current;
    }
    return acc;
  }, [] as AISuggestion[]);
  
  // 5. Ordenar y limitar resultados
  uniqueSuggestions.sort((a, b) => b.confidence - a.confidence);
  const topSuggestions = uniqueSuggestions.slice(0, 6);
  
  console.log('‚úÖ Enhanced Analyzer - Found suggestions:', topSuggestions.length);
  console.log('üìä Top suggestions:', topSuggestions.map(s => 
    `${s.scaleId}: ${s.confidence.toFixed(3)}`).join(', '));
  
  // DEBUGGING FINAL
  if (topSuggestions.length === 0 && text.length > 5) {
    console.warn('‚ö†Ô∏è NO SUGGESTIONS FOUND for text:', text);
    console.warn('‚ö†Ô∏è Normalized text:', normalizedText);
  }
  
  return {
    suggestions: topSuggestions,
    timestamp: Date.now()
  };
};

// ============================================================================
// HOOK PARA REACT CON DEBOUNCING
// ============================================================================

import { useState, useEffect } from 'react';

export const useEnhancedAIAnalysis = (text: string, delay: number = 1000) => {
  const [analysis, setAnalysis] = useState<AIAnalysisResult>({
    suggestions: [],
    timestamp: Date.now()
  });
  
  useEffect(() => {
    const timer = setTimeout(() => {
      const result = analyzeTextEnhanced(text);
      setAnalysis(result);
    }, delay);
    
    return () => clearTimeout(timer);
  }, [text, delay]);
  
  return analysis;
};

// ============================================================================
// FUNCIONES DE UTILIDAD PARA DEBUGGEO
// ============================================================================

/**
 * üîß FUNCI√ìN DE DEBUG - Ver patrones generados
 * √ötil para debugging y verificaci√≥n
 */
export const debugPatterns = () => {
  const patterns = generatePatternsFromScales();
  console.table(patterns.map(p => ({
    Scale: p.scaleId,
    Keywords: p.keywords.slice(0, 5).join(', ') + '...',
    Total: p.keywords.length,
    Confidence: p.baseConfidence
  })));
  return patterns;
};

/**
 * üß™ FUNCI√ìN DE TEST - Probar an√°lisis con texto
 */
export const testAnalysis = (text: string, expectedScales: string[] = []) => {
  const result = analyzeTextEnhanced(text);
  console.log('\nüß™ TEST RESULTS:');
  console.log('Input:', text.substring(0, 100));
  console.log('Expected scales:', expectedScales);
  console.log('Found suggestions:', result.suggestions.map(s => s.scaleId));
  
  const found = result.suggestions.map(s => s.scaleId);
  const success = expectedScales.every(scale => found.includes(scale));
  console.log(success ? '‚úÖ TEST PASSED' : '‚ùå TEST FAILED');
  
  return { result, success };
};

// ============================================================================
// EXPORTAR FUNCIONES GLOBALMENTE PARA DEBUG EN BROWSER
// ============================================================================

// Hacer funciones disponibles globalmente para debugging
if (typeof window !== 'undefined') {
  (window as any).analyzeTextEnhanced = analyzeTextEnhanced;
  (window as any).debugPatterns = debugPatterns;
  (window as any).testAnalysis = testAnalysis;
  
  console.log('ü§ñ Enhanced AI Analyzer cargado. Funciones disponibles:');
  console.log('   - analyzeTextEnhanced(text)');
  console.log('   - debugPatterns()');
  console.log('   - testAnalysis(text, expectedScales)');
}